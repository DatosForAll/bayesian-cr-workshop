---
title: "Skip your coffee break: Speed up MCMC convergence"
author: "The team"
date: "last updated: `r Sys.Date()`"
output:
  xaringan::moon_reader:
    css: [default, "slides-theme.css"]
    lib_dir: libs
    nature:
      ratio: '16:9'
      highlightStyle: github
      highlightLines: true
      slideNumberFormat: ''
      titleSlideClass: [center, middle]
---

```{r setup, include=FALSE, echo=FALSE, message=FALSE, warning=FALSE}
options(htmltools.dir.version = FALSE)
knitr::opts_chunk$set(comment = "")
library(tidyverse)
theme_set(theme_light())
update_geom_defaults("point", list(size = 2)) 
library(here)
library(nimble)
library(MCMCvis)
```


---
## Our `nimble` workflow so far

![](img/nimble_workflow_sofar.png)


---
## But `nimble` gives full access to the MCMC engine

--

![](img/nimble_workflow.png)

---
## Steps to use NIMBLE at full capacity

1. Build the model. It is an R object.
2. Build the MCMC.
3. Compile the model and MCMC.
4. Run the MCMC.
5. Extract the samples.

- `nimbleMCMC` does all of this at once.

---
class: middle, center

# Back to CJS models with Dipper data. 

---
### Define model

```{r echo = FALSE, message = FALSE, warning = FALSE}
dipper <- read_csv(here::here("slides", "dat", "dipper.csv"))
y <- dipper %>%
  select(year_1981:year_1987) %>%
  as.matrix()
first <- apply(y, 1, function(x) min(which(x !=0)))
my.constants <- list(N = nrow(y), T = ncol(y), first = first)
my.data <- list(y = y + 1)
zinits <- y + 1 # non-detection -> alive
zinits[zinits == 2] <- 1 # dead -> alive
initial.values <- function() list(phi = runif(1,0,1),
                                  p = runif(1,0,1),
                                  z = zinits)
parameters.to.save <- c("phi", "p")
n.iter <- 2500
n.burnin <- 1000
n.chains <- 2
```

.tiny-font[
```{r, eval = TRUE, echo = TRUE, message = FALSE, warning=FALSE}
hmm.phip <- nimbleCode({
  delta[1] <- 1              # Pr(alive t = 1) = 1
  delta[2] <- 0              # Pr(dead t = 1) = 0
    phi ~ dunif(0, 1)     # prior survival
    gamma[1,1] <- phi        # Pr(alive t -> alive t+1)
    gamma[1,2] <- 1 - phi    # Pr(alive t -> dead t+1)
    gamma[2,1] <- 0          # Pr(dead t -> alive t+1)
    gamma[2,2] <- 1          # Pr(dead t -> dead t+1)
    p ~ dunif(0, 1)       # prior detection
    omega[1,1] <- 1 - p    # Pr(alive t -> non-detected t)
    omega[1,2] <- p        # Pr(alive t -> detected t)
    omega[2,1] <- 1        # Pr(dead t -> non-detected t)
    omega[2,2] <- 0        # Pr(dead t -> detected t)
  # likelihood
  for (i in 1:N){
    z[i,first[i]] ~ dcat(delta[1:2])
    for (j in (first[i]+1):T){
      z[i,j] ~ dcat(gamma[z[i,j-1], 1:2])
      y[i,j] ~ dcat(omega[z[i,j], 1:2])
    }
  }
})
```
]

---
### Run and summarise

.tiny-font[
```{r, eval = TRUE, echo = TRUE, warning=FALSE, message=FALSE}
mcmc.phip <- nimbleMCMC(code = hmm.phip, 
                         constants = my.constants,
                         data = my.data,              
                         inits = initial.values,
                         monitors = parameters.to.save,
                         niter = n.iter,
                         nburnin = n.burnin, 
                         nchains = n.chains)
```
]

.tiny-font[
```{r, eval = TRUE, echo=TRUE}
MCMCsummary(object = mcmc.phip, round = 2)
```
]

---
class: middle, center

# Detailed Nimble workflow

---
## 1. Build the model (R object)

.tiny-font[
```{r, eval = TRUE, echo = TRUE}
hmm.phip <- nimbleModel(code = hmm.phip,
                        constants = my.constants,
                        data = my.data,
                        inits = initial.values())
```
]

---
## 2. Build the MCMC

.small-font[
```{r, eval = TRUE, echo = TRUE, message = TRUE}
phip.mcmc <- buildMCMC(hmm.phip)
```
]

---
## 3. Compile the model and MCMC

.small-font[
```{r, eval = TRUE, echo = TRUE, message = TRUE}
phip.model <- compileNimble(hmm.phip) 
c.phip.mcmc <- compileNimble(phip.mcmc, project = phip.model)
```
]

---
## 4. Run the MCMC

.small-font[
```{r, eval = TRUE, echo = TRUE, message = TRUE}
c.phip.mcmc$run(1000)
```
]

---
## 5. Extract samples and summarise

.small-font[
```{r, eval = TRUE, echo = TRUE, message = TRUE}
samples <- as.matrix(c.phip.mcmc$mvSamples)
summary(samples[,"phi"])
summary(samples[,"p"])
```
]

---
class: middle, center

# Why is it useful? 

---
## Use and debug model in `R`

+ Makes your life easier when it comes to debugging

+ Inspect variables

```{r}
hmm.phip$gamma
```

+ Calculate likelihood

```{r}
hmm.phip$calculate()
```


---
## Open the hood, and change/modify/write samplers

+ Slice samplers instead of Metropolis-Hastings.

+ Blocking correlated parameters.

+ To know all samplers available in Nimble, type in `help(samplers)`.

+ Source code for samplers and distributions is **in R** and can be copied and modified.

+ Use [`compareMCMCs` package](https://github.com/nimble-dev/compareMCMCs) to compare options (including Stan and Jags!). 

???

compareMCMCs status: It has been in waiting zone for release as its own package. It is pretty much ready and we need to get it out, maybe by the workshop. It is no longer a function in nimble.


---
class: middle, center

## Consider a model with wing length and individual random effect on survival.  

---

```{r echo = FALSE, message = FALSE, warning=FALSE}
dipper <- read_csv(here::here("slides", "dat", "dipper.csv"))
y <- dipper %>%
  select(year_1981:year_1987) %>%
  as.matrix()
first <- apply(y, 1, function(x) min(which(x !=0)))
wing.length.st <- as.vector(scale(dipper$wing_length))
my.constants <- list(N = nrow(y), 
                     T = ncol(y), 
                     first = first,
                     winglength = wing.length.st)
zinits <- y + 1 # non-detection -> alive
zinits[zinits == 2] <- 1 # dead -> alive
initial.values <- function() list(beta = rnorm(2,0,1.5),
                                  sdeps = runif(1,0,3),
                                  p = runif(1,0,1),
                                  z = zinits)
parameters.to.save <- c("beta", "sdeps", "p")
n.iter <- 10000
n.burnin <- 2500
n.chains <- 2
```

.tiny-font[
```{r}
hmm.phiwlrep <- nimbleCode({
    p ~ dunif(0, 1) # prior detection
    omega[1,1] <- 1 - p    # Pr(alive t -> non-detected t)
    omega[1,2] <- p        # Pr(alive t -> detected t)
    omega[2,1] <- 1        # Pr(dead t -> non-detected t)
    omega[2,2] <- 0        # Pr(dead t -> detected t)
  for (i in 1:N){
    logit(phi[i]) <- beta[1] + beta[2] * winglength[i] + eps[i] #<<
    eps[i] ~ dnorm(mean = 0, sd = sdeps) #<<
    gamma[1,1,i] <- phi[i]      # Pr(alive t -> alive t+1)
    gamma[1,2,i] <- 1 - phi[i]  # Pr(alive t -> dead t+1)
    gamma[2,1,i] <- 0           # Pr(dead t -> alive t+1)
    gamma[2,2,i] <- 1           # Pr(dead t -> dead t+1)
  }
  beta[1] ~ dnorm(mean = 0, sd = 1.5)
  beta[2] ~ dnorm(mean = 0, sd = 1.5)
  sdeps ~ dunif(0, 10)
  delta[1] <- 1          # Pr(alive t = 1) = 1
  delta[2] <- 0          # Pr(dead t = 1) = 0
  # likelihood
  for (i in 1:N){
    z[i,first[i]] ~ dcat(delta[1:2])
    for (j in (first[i]+1):T){
      z[i,j] ~ dcat(gamma[z[i,j-1], 1:2, i]) #<<
      y[i,j] ~ dcat(omega[z[i,j], 1:2])
    }
  }
})
```
]

```{r echo = FALSE, eval = FALSE}
mcmc.phiwlrep <- nimbleMCMC(code = hmm.phiwlrep, 
                            constants = my.constants,
                            data = my.data,              
                            inits = initial.values,
                            monitors = parameters.to.save,
                            niter = n.iter,
                            nburnin = n.burnin, 
                            nchains = n.chains)
save(mcmc.phiwlrep, file = here::here("slides", "dat", "wl.RData"))
```


---
## Standard deviation of the random effect

```{r echo = FALSE, message=FALSE, warning=FALSE}
load(here::here("slides", "dat", "wl.RData"))
```
```{r, echo = FALSE, fig.width = 7.5, fig.asp = 0.718, dev = "svg", message=FALSE, warning=FALSE, fig.align="center"}
MCMCtrace(mcmc.phiwlrep, params = "sdeps", pdf = FALSE)
```

---
## Change samplers

+ What are the samplers used by default?

```{r echo = FALSE, warning=FALSE, message=FALSE}
hmm.phiwlrep <- nimbleModel(code = hmm.phiwlrep,
                            constants = my.constants,
                            data = my.data,
                            inits = initial.values())
```

.tiny-font[
```{r}
mcmcConf <- configureMCMC(hmm.phiwlrep)
```
]

---
## Remove default sampler, and use slice sampler

.tiny-font[
```{r}
mcmcConf$removeSamplers('sdeps')
mcmcConf$addSampler(target = 'sdeps',
                    type = "slice") #<<
mcmcConf
```
]

<br>
<br>

```{r, echo = FALSE, fig.width = 7.5, fig.asp = 0.618, dev = "svg", warning=FALSE, message=FALSE, fig.align="center"}
Rmcmc <- buildMCMC(mcmcConf)
Cmodel <- compileNimble(hmm.phiwlrep)
Cmcmc <- compileNimble(Rmcmc, project=hmm.phiwlrep)
Cmcmc$run(10000)
samples1 <- as.matrix(Cmcmc$mvSamples)
Cmcmc$run(10000)
samples2 <- as.matrix(Cmcmc$mvSamples)
df <- data.frame(iter = c(2501:10000, 2501:10000),
                 samples = c(samples1[2501:10000,"sdeps"], samples2[2501:10000,"sdeps"]), 
                 chain = c(rep("chain 1", length(samples1[2501:10000,"sdeps"])),
                           rep("chain 2", length(samples2[2501:10000,"sdeps"]))))
df.beta <- data.frame(iter = c(2501:10000, 2501:10000),
                 beta1 = c(samples1[2501:10000,"beta[1]"], samples2[2501:10000,"beta[1]"]), 
                 beta2 = c(samples1[2501:10000,"beta[2]"], samples2[2501:10000,"beta[2]"]), 
                 chain = c(rep("chain 1", length(samples1[2501:10000,"sdeps"])),
                           rep("chain 2", length(samples2[2501:10000,"sdeps"]))))
```

---
## Trace plot

```{r, echo = FALSE, fig.width = 7.5, fig.asp = 0.618, dev = "svg", warning=FALSE, message=FALSE, fig.align="center"}
df %>%
  ggplot() + 
  aes(x = iter, y = samples, group = chain, color = chain) + 
  geom_line() + 
  labs(x = "iterations", y = "random effect standard deviation", color = "")
```


---
## Block sampling

+ High correlation in (regression) parameters may make independent samplers inefficient.

```{r, echo = FALSE, fig.width = 7.5, fig.asp = 0.418, dev = "svg", fig.align="center"}
df.beta %>%
  ggplot() + 
  aes(x = beta1, y = beta2, group = chain, color = chain) +
  geom_point(alpha = .2) + 
  labs(x = "beta1", y = "beta2", color = "")
```

+ Block sampling (propose candidate values from multivariate distribution) might help.

---
## Block sampling

+ Remove and replace independent RW samples by block sampling. Then proceed as usual.

.tiny-font[
```{r message = FALSE, warning=FALSE}
mcmcConf$removeSamplers(c('beta[1]','beta[2]'))
mcmcConf$addSampler(target = c('beta[1]','beta[2]'),
                    type = "RW_block") #<<
```
]

---
## Block sampling

.tiny-font[
```{r message = FALSE, warning=FALSE}
mcmcConf
```
]

---
## Summary of strategies for improving MCMC 

--

+ Choose better initial values.

--

+ Customize sampler choice.

--

+ Reparameterize, e.g. standardize covariates, deal with parameter redundancy.

--

+ Rewrite the model.

    + Vectorize to improve computational efficiency (not covered).
    + Marginalize to remove parameters

--

+ Write new samplers that take advantage of particular model structures (not covered).

--

+ Using multiple cores with parallelization: see how-to at <https://r-nimble.org/nimbleExamples/parallelizing_NIMBLE.html>


---
## Marginalization

+ User-defined distributions is another neat feature of Nimble.

+ Integrate over latent states if those are not the focus of ecological inference (marginalization).

+ In general, marginalization improves MCMC. 

+ The [NimbleEcology](https://cran.r-project.org/web/packages/nimbleEcology/vignettes/Introduction_to_nimbleEcology.html) implements capture-recapture models and HMMs with marginalization. 

---

+ [Olivier to add Geese example].

---
## Weighted likelihood w/ unique capture history

+ [Olivier to add Geese example]


---
background-color: #234f66
## <span style="color:white">No live demo, but there is a worksheet.</span>

.center[
![](img/b5b086f9cc403008ba7be5dd508cfed2.gif)
]



---
## Further reading

+ Turek, D., de Valpine, P. & Paciorek, C.J. [Efficient Markov chain Monte Carlo sampling for hierarchical hidden Markov models](https://doi.org/10.1007/s10651-016-0353-z). Environ Ecol Stat 23, 549–564 (2016).

+ Nimble workshop to come 26-28 May, check out [here](https://r-nimble.org/nimble-virtual-short-course-may-26-28).

+ Nimble workshop material online available [here](https://github.com/nimble-training).

+ Nimble [manual](https://r-nimble.org/html_manual/cha-welcome-nimble.html) and [cheatsheet](https://r-nimble.org/cheatsheets/NimbleCheatSheet.pdf). 
